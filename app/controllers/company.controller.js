const db = require("../models");

const BD_Users = db.DBS['Database0'];

const FUN_0 = (db) => db.fun_0;
const FUN_1 = (db) => db.fun_1;
const FUN_2 = (db) => db.fun_2;
const FUN_51 = (db) => db.fun_51;
const FUN_52 = (db) => db.fun_52;
const Submit = (db) => db.submit;
const EXP = (db) => db.expedition;
const CERT = (db) => db.certification;

const Op = db.Sequelize.Op;
const Sequelize = db.Sequelize;
const fs = require('fs');
const PDFDocument = require('pdfkit');
const { QueryTypes } = require('sequelize');
const pdfSupport = require("../resources/pdf.lib.js");
const { verifyPermit } = require("../resources/permits.controller");
const { corbanAudit } = require("../resources/audits.controller");
const { validateDB, getDbData } = require("../resources/jwt.module");

const queries = require('../resources/sqlQueries')
const moment = require('moment');
const { downloadExt, download } = require("./files.controller");

exports.taxCalculation = (req, res) => {
    const DB = validateDB(req);

    getDbData(BD_Users, DB.name).then(info => _continue_(info));

    function _continue_(info) {
        if (!info) return res.send('ERROR');
        let DATA = {}

        let companyInfo = info.companyInfo
        companyInfo.indexName = info.bdname
        companyInfo.name = info.name

        let descs = req.body.descs ? req.body.descs.split(';') : [];
        let values = req.body.values ? req.body.values.split(';') : [];

        DATA.companyInfo = companyInfo
        DATA.descs = descs
        DATA.values = values
        DATA.total = req.body.total ? req.body.total : '0';
        DATA.lang = req.body.lang ? req.body.lang : 'en';

        const path = '/docs/public/output_tax_calculation.pdf';
        DATA.path = path;
        const fileName = 'tax.pdf'
        genPDF_taxCalculation(DATA);
        setTimeout(() => download(res, path, fileName), 1000)
    }
};


function genPDF_taxCalculation(DATA) {
    var doc = new PDFDocument({
        size: 'LETTER', margins: {
            top: 120,
            bottom: 56,
            left: 56,
            right: 56
        },
        bufferPages: true,
    });

    let lang = DATA.lang;

    let BODY = {
        es: `Apreciado usuario, tenga en cuenta:`,
        en: `Dear user, please note:`,
    }
    let BODY2 = {
        es: `Las expensas es el ingreso que percibe el curador urbano por los servicios prestados, tiene como finalidad cubrir los gastos en que incurre para desarrollar su labor; tales como el pago del grupo interdisciplinario, los costos operativos y la remuneración del curador urbano. Son liquidadas por los curadores urbanos quienes las liquidan y expiden factura una vez el solicitante del trámite ha hecho los pagos. El cargo variable es un requisito de radicación (artículo 2.2.6.6.8.5) y el mismo no es objeto de reembolso.`,
        en: `The expenses are the income received by the urban curator for the services provided, its purpose is to cover the expenses incurred to carry out their work; such as the payment of the interdisciplinary group, the operating costs and the remuneration of the urban curator. They are settled by the urban curators who settle them and issue an invoice once the applicant for the procedure has made the payments. The variable charge is a filing requirement (article 2.2.6.6.8.5) and it is not subject to reimbursement.`,
    }
    let BODY3 = {
        en: `This preview is used to simulate the expenses of the administrative acts generated by the curatorship.`,
        es: `Esta vista previa es usada para simular las expensas de los actos administrativos generados por la curaduría.`,
    }
    let BODY4 = {
        en: `The values resulting from this document do not reflect under any criteria the final value given by the curatorship.`,
        es: `Los valores resultado de este documento no reflejan bajo ningún criterio el valor final dado por la curaduría.`,
    }
    let BODY5 = {
        en: `Verbal consultations on general information on the urban regulations in force in the municipality or district will not generate expenses in favor of the urban curator. `,
        es: `Las consultas verbales sobre información general de las normas urbanísticas vigentes en el municipio o distrito no generarán expensas a favor del curador urbano. `,
    }
    let MADE = {
        en: `Generated: ${moment().format('YYYY-MM-DD HH:mm')}`,
        es: `Generado el: ${moment().format('YYYY-MM-DD HH:mm')}`,
    }

    let trn = {
        en: {
            title: 'BILL PREVIEW',
            desc: 'DESCRIPTION',
            value: 'VALUE',
            total: 'TOTAL',
        },
        es: {
            title: 'LIQUIDACIÓN PREVIA',
            desc: 'DESCRIPCIÓN',
            value: 'VALOR',
            total: 'TOTAL',
        }
    }

    doc.pipe(fs.createWriteStream('.'+DATA.path));

    doc.fontSize(10);
    doc.text('\n');
    doc.text(BODY[lang]);
    doc.moveDown();

    doc.text(BODY2[lang], { align: 'justify' });
    doc.moveDown();

    doc.text(BODY3[lang], { align: 'justify' });
    doc.moveDown();

    doc.text(BODY4[lang], { align: 'justify' });
    doc.moveDown();

    doc.text(BODY5[lang], { align: 'justify' });
    doc.moveDown();


    pdfSupport.table(doc,
        [
            { coord: [0, 0], w: 60, h: 1, text: trn[lang].title, config: { align: 'center', fill: 'silver', bold: true } },
        ],
        [doc.x, doc.y], [60, 1], { lineHeight: -1 })
    pdfSupport.table(doc,
        [
            { coord: [0, 0], w: 50, h: 1, text: trn[lang].desc, config: { align: 'left', fill: 'gainsboro', bold: true } },
            { coord: [50, 0], w: 10, h: 1, text: trn[lang].value, config: { align: 'right', fill: 'gainsboro', bold: true } },
        ],
        [doc.x, doc.y], [60, 1], { lineHeight: -1 })

    DATA.descs.map((desc, i) => pdfSupport.table(doc,
        [
            { coord: [0, 0], w: 50, h: 1, text: desc, config: { align: 'left', } },
            { coord: [50, 0], w: 10, h: 1, text: DATA.values[i], config: { align: 'right', } },
        ],
        [doc.x, doc.y], [60, 1], { lineHeight: -1 }))

    pdfSupport.table(doc,
        [
            { coord: [0, 0], w: 50, h: 1, text: `${trn[lang].total}: `, config: { align: 'right', bold: true } },
            {
                coord: [50, 0], w: 10, h: 1, text: DATA.total, config: { align: 'right', bold: true }
            },
        ],
        [doc.x, doc.y], [60, 1], { lineHeight: -1 })

    doc.moveDown();
    doc.text(MADE[lang]);

    pdfSupport.setHeader(doc, { title: trn[lang].title, icon: true }, DATA.companyInfo, lang)
    pdfSupport.setBottom(doc, false, true, false, DATA.companyInfo, lang)


    doc.end();
    return true;

}


// DICTIONARY QUERIES

exports.get_lic = (req, res) => {
    const DB = validateDB(req);

    const fun_0_attributes = ['id_public', 'state'];
    const fun_1_attributes = ['tipo', 'tramite', 'm_urb', 'm_sub', 'm_lic'];

    getDbData(BD_Users, DB.name).then(info => _continue_(info));

    function _continue_(info) {
        if (!info.technicalInfo) return res.send('NO CONFIG');
        if (!info.technicalInfo.serials) return res.send('NO CONFIG');
        if (!info.technicalInfo.serials.process) return res.send('NO CONFIG');

        const companyID = info.technicalInfo.serials.process;

        FUN_0(DB).findAll({
            attributes: fun_0_attributes,
            where: {
                id_public: { [Op.like]: companyID + '%' }
            },
            include: [
                {
                    model: FUN_1(DB),
                    attributes: fun_1_attributes,
                    where: { version: 1 }
                }
            ]
        })
            .then(data => {
                res.send(data);
            })
            .catch(err => {
                res.status(500).send({ message: err.message || "Some error occurred while retrieving DATA." });
            });
    }

};

exports.get_oa = (req, res) => {
    const DB = validateDB(req);

    const fun_0_attributes = ['id_public', 'state'];
    const fun_1_attributes = ['tipo', 'tramite', 'm_urb', 'm_sub', 'm_lic'];

    getDbData(BD_Users, DB.name).then(info => _continue_(info));

    function _continue_(info) {
        if (!info.technicalInfo) return res.send('NO CONFIG');
        if (!info.technicalInfo.serials) return res.send('NO CONFIG');
        if (!info.technicalInfo.serials.process) return res.send('NO CONFIG');

        const companyID = info.technicalInfo.serials.process;

        FUN_0(DB).findAll({
            attributes: fun_0_attributes,
            where: {
                id_public: { [Op.notLike]: companyID + '%' }
            },
            include: [
                {
                    model: FUN_1(DB),
                    attributes: fun_1_attributes,
                    where: { version: 1 }
                }
            ]
        })
            .then(data => {
                res.send(data);
            })
            .catch(err => {
                res.status(500).send({ message: err.message || "Some error occurred while retrieving DATA." });
            });
    }


};

exports.get_in = (req, res) => {
    const DB = validateDB(req);

    const attributes = ['id_public', 'id_related', 'type', 'date', 'time'];

    Submit(DB).findAll({
        attributes: attributes,
    })
        .then(data => {
            res.send(data);
        })
        .catch(err => {
            res.status(500).send({ message: err.message || "Some error occurred while retrieving DATA." });
        });

};

exports.get_out = (req, res) => {
    const DB = validateDB(req);

    getDbData(BD_Users, DB.name).then(info => _continue_(info));

    function _continue_(info) {
        if (!info.technicalInfo) return res.send('NO CONFIG');
        if (!info.technicalInfo.serials) return res.send('NO CONFIG');
        if (!info.technicalInfo.serials.end) return res.send('NO CONFIG');

        let END_SERIAL = info.technicalInfo.serials.end;

        DB.query(queries.getCubDictionary(END_SERIAL), { type: QueryTypes.SELECT })
            .then(data => {
                res.send(data);
            }).catch(err => { res.status(500).send({ message: err.message || "Some error occurred." }); });

    }


};

exports.get_res = (req, res) => {
    const DB = validateDB(req);

    const attributes = ['id_public', 'date',];
    const fun_0_attributes = ['id_public', 'state'];
    const fun_1_attributes = ['tipo', 'tramite', 'm_urb', 'm_sub', 'm_lic'];

    EXP(DB).findAll({
        attributes: attributes,
        where: { id_public: { [Op.ne]: null } },
        include: {
            model: FUN_0(DB),
            attributes: fun_0_attributes,
            include: {
                model: FUN_1(DB),
                attributes: fun_1_attributes,
                where: { version: 1 }
            }
        }

    })
        .then(data => {
            res.send(data);
        })
        .catch(err => {
            res.status(500).send({ message: err.message || "Some error occurred while retrieving DATA." });
        });

};

exports.get_cert = (req, res) => {
    const DB = validateDB(req);
    const attributes = ['id_public', 'description', 'id_related', 'related', 'createdAt'];

    CERT(DB).findAll({
        attributes: attributes,
    })
        .then(data => {
            res.send(data);
        })
        .catch(err => {
            res.status(500).send({ message: err.message || "Some error occurred while retrieving DATA." });
        });

};

exports.get_tit = (req, res) => {
    const DB = validateDB(req);

    const attributes = ['name', 'surname', 'id_number', 'type', 'rep_name', 'rep_id_number',
        [Sequelize.fn('max', Sequelize.col('nunber')), 'nunber'],
        [Sequelize.fn('max', Sequelize.col('email')), 'email'],
        [Sequelize.fn('GROUP_CONCAT', Sequelize.literal(`DISTINCT id_public SEPARATOR ', '`)), 'id_related'],
    ];

    FUN_51(DB).findAll({
        attributes: attributes,
        group: ['id_number'],
        include: [{
            model: FUN_0(DB),
            attributes: ['id_public']
        }]
    })
        .then(data => {
            res.send(data);
        })
        .catch(err => {
            res.status(500).send({ message: err.message || "Some error occurred while retrieving DATA." });
        });

};

exports.get_prof = (req, res) => {
    const DB = validateDB(req);

    const attributes = ['name', 'surname', 'id_number', 'registration', 'docs',
        [Sequelize.fn('max', Sequelize.col('number')), 'number'],
        [Sequelize.fn('max', Sequelize.col('email')), 'email'],
        [Sequelize.fn('GROUP_CONCAT', Sequelize.literal(`DISTINCT id_public SEPARATOR ', '`)), 'id_related'],
    ];

    FUN_52(DB).findAll({
        attributes: attributes,
        group: ['id_number'],
        include: [{
            model: FUN_0(DB),
            attributes: ['id_public']
        }]
    })
        .then(data => {
            res.send(data);
        })
        .catch(err => {
            res.status(500).send({ message: err.message || "Some error occurred while retrieving DATA." });
        });


};

exports.get_prev = (req, res) => {
    const DB = validateDB(req);

    const attributes = ['direccion', 'direccion_ant', 'matricula', 'catastral', 'catastral_2',
        'barrio', 'vereda', 'comuna', 'sector', 'estrato', 'corregimiento', 'manzana', 'lote',
        [Sequelize.fn('GROUP_CONCAT', Sequelize.literal(`DISTINCT id_public SEPARATOR ', '`)), 'id_related'],
    ];

    FUN_2(DB).findAll({
        attributes: attributes,
        group: ['catastral'],
        include: [{
            model: FUN_0(DB),
            attributes: ['id_public']
        }]
    })
        .then(data => {
            res.send(data);
        })
        .catch(err => {
            res.status(500).send({ message: err.message || "Some error occurred while retrieving DATA." });
        });

};


exports.get_logo = (req, res) => {
    const DB = validateDB(req);
    getDbData(BD_Users, DB.name).then(info => {
        const path = info.bdname + '/logo.img';
        downloadExt(res, path, 'logo.png')

    }).catch(err => {
        res.status(500).send({ message: err.message });
    });

};

exports.get_sign = (req, res) => {
    const DB = validateDB(req);
    getDbData(BD_Users, DB.name).then(info => {
        const path = info.bdname + '/sign.img';
        downloadExt(res, path, 'sign.png')

    }).catch(err => {
        res.status(500).send({ message: err.message });
    });

};

exports.set_logo = (req, res) => {
    const DB = validateDB(req);
    getDbData(BD_Users, DB.name).then(info => {
        res.send('OK')

    }).catch(err => {
        res.status(500).send({ message: err.message });
    });

};

exports.set_sign = (req, res) => {
    const DB = validateDB(req);
    getDbData(BD_Users, DB.name).then(info => {
        res.send('OK')

    }).catch(err => {
        res.status(500).send({ message: err.message });
    });

};